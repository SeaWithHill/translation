# 基于水位线过期时间的AsyncLoadingCache

## 1.背景


- 1.1 数据保存在MySQL之中。
- 1.2 为了减轻数据库压力，对应的信息经过一定聚合与包装，并缓存到了Redis中，通过【定时任务+变更时的埋点方式】刷新DB信息到Redis。
- 1.3 在高并发场景下, 对存储需求不大的信息，使用 Caffeine 配置了本地缓存，减少Redis请求， 可以有效降低延迟。
- 1.4 本地缓存 Caffeine 根据写入时间, 设置了过期策略。

## 2. 问题

在爆发式的瞬时并发流量到达时，如果碰上缓存过期，这时候就会有大量的 Cache Loading 请求打到 Redis，造成延迟指标的瞬间上涨。

- 指标的95线看着没什么问题，但是99线可能不好看。
- 基于硬指标【比如: 最大200ms响应时间】的告警信息也会出现。
## 3. 需求

降低这种瞬间的延迟指标上涨

## 4. 可选的解决方案

- 4.1 重新基于业务，定制包装缓存的数据结构。 
- 4.2 创建一个【基于水位线过期时间的AsyncLoadingCache】。


## 5. 实现思路

- 5.1 初次请求, 本地缓存中没有数据, 只能到Redis之中加载，这个避免不了。 优化手段是使用预热方法，比如在系统启动完成后通过Spring的一些事件钩子主动执行加载，或者是 devops 工具在接入流量之前进行请求预热。
- 5.2 缓存配置上设置水位线过期策略， 比如低水位线是1分钟，高水位线是10分钟。 
  * 5.2.1 如果当前时间，与数据写入的时间差距小于低水位线【比如低于1分钟】，不会触发加载。
  * 5.2.2 如果当前时间，与数据写入的时间差距大于低水位线，但是小于高水位线【比如高于1分钟, 但是低于10分钟】，触发异步加载，并立即返回缓存数据; 异步加载完成之后刷新到缓存之中。


## 6. 实现代码

> [保密: AsyncLoadingCacheTest.java](./AsyncLoadingCacheTest.java)



创作日期: 2024年09月26日